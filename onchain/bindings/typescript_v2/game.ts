// Generated by dojo-bindgen on Sat, 1 Jun 2024 08:09:52 +0000. Do not modify this file manually.
import { Account } from "starknet";
import {
    Clause,
    Client,
    ModelClause,
    createClient,
    valueToToriiValueAndOperator,
} from "@dojoengine/torii-client";
import {
    LOCAL_KATANA,
    LOCAL_RELAY,
    LOCAL_TORII,
    createManifestFromJson,
} from "@dojoengine/core";

// Type definition for `game::models::storage::battles::battleStorage::BattleStorage` struct
export interface BattleStorage {
    owner: string;
    map: number;
    level: number;
    entitiesCount: number;
    aliveEntitiesCount: number;
    isBattleOver: boolean;
    isWaitingForPlayerAction: boolean;
}

// Type definition for `core::byte_array::ByteArray` struct
export interface ByteArray {
    data: string[];
    pending_word: string;
    pending_word_len: number;
}

// Type definition for `core::option::Option::<core::integer::u32>` enum
type Option<A> = { type: 'Some'; data: A; } | { type: 'None'; }

// Type definition for `game::models::storage::arena::arenaConfig::ArenaConfig` struct
export interface ArenaConfig {
    id: number;
    enemyRangesByRankLength: number;
    gemsRewardsLength: number;
}


// Type definition for `game::models::storage::arena::arenaAccount::ArenaAccount` struct
export interface ArenaAccount {
    owner: string;
    rank: bigint;
    lastClaimedRewards: bigint;
}


// Type definition for `game::models::storage::level::levelInfos::LevelInfos` struct
export interface LevelInfos {
    map: number;
    level: number;
    energyCost: number;
    enemiesCount: number;
}


// Type definition for `game::models::storage::battles::healthOnTurnProcStorage::HealthOnTurnProcStorage` struct
export interface HealthOnTurnProcStorage {
    owner: string;
    map: number;
    entityIndex: number;
    index: number;
    healthOnTurnProc: HealthOnTurnProc;
}

// Type definition for `game::models::battle::entity::healthOnTurnProc::HealthOnTurnProc` struct
export interface HealthOnTurnProc {
    entityIndex: number;
    value: bigint;
    duration: number;
    damageOrHeal: DamageOrHealEnum;
}

// Type definition for `game::models::battle::entity::healthOnTurnProc::DamageOrHealEnum` enum
type DamageOrHealEnum = { type: 'Damage'; } | { type: 'Heal'; }

// Type definition for `game::models::hero::Hero` struct
export interface Hero {
    id: number;
    name: string;
    level: number;
    rank: number;
    experience: number;
    runes: EquippedRunes;
}

// Type definition for `game::models::account::heroes::Heroes` struct
export interface Heroes {
    owner: string;
    index: number;
    hero: Hero;
}

// Type definition for `game::models::hero::equippedRunes::EquippedRunes` struct
export interface EquippedRunes {
    isFirstRuneEquipped: boolean;
    first: number;
    isSecondRuneEquipped: boolean;
    second: number;
    isThirdRuneEquipped: boolean;
    third: number;
    isFourthRuneEquipped: boolean;
    fourth: number;
    isFifthRuneEquipped: boolean;
    fifth: number;
    isSixthRuneEquipped: boolean;
    sixth: number;
}


// Type definition for `game::models::storage::level::levelEnemy::LevelEnemy` struct
export interface LevelEnemy {
    map: number;
    level: number;
    index: number;
    hero: Hero;
}


// Type definition for `game::models::account::Account` struct
export interface Account {
    owner: string;
    username: string;
    energy: number;
    pvpEnergy: number;
    crystals: number;
    gems: number;
    lastEnergyUpdateTimestamp: bigint;
    lastPvpEnergyUpdateTimestamp: bigint;
    runesCount: number;
    heroesCount: number;
}


// Type definition for `game::models::storage::skill::skillNameSet::SkillNameSet` struct
export interface SkillNameSet {
    heroName: string;
    skill0: string;
    skill1: string;
    skill2: string;
}


// Type definition for `game::models::battle::entity::statistics::Statistics` struct
export interface Statistics {
    maxHealth: bigint;
    health: I64;
    attack: Statistic;
    defense: Statistic;
    speed: Statistic;
    criticalChance: Statistic;
    criticalDamage: Statistic;
}

// Type definition for `game::models::battle::entity::cooldowns::Cooldowns` struct
export interface Cooldowns {
    skill1: number;
    skill2: number;
}

// Type definition for `game::models::storage::battles::entityStorage::EntityStorage` struct
export interface EntityStorage {
    owner: string;
    map: number;
    entityIndex: number;
    entityVal: Entity;
    healthOnTurnProcCount: number;
}

// Type definition for `game::models::battle::entity::statistics::statModifier::StatModifier` struct
export interface StatModifier {
    value: bigint;
    duration: number;
}

// Type definition for `game::models::battle::entity::stunOnTurnProc::StunOnTurnProc` struct
export interface StunOnTurnProc {
    duration: number;
    stunned: boolean;
}

// Type definition for `game::models::battle::entity::Entity` struct
export interface Entity {
    index: number;
    heroId: number;
    name: string;
    turnBar: TurnBar;
    statistics: Statistics;
    cooldowns: Cooldowns;
    stunOnTurnProc: StunOnTurnProc;
    allyOrEnemy: AllyOrEnemy;
}

// Type definition for `game::utils::signedIntegers::i64::i64` struct
export interface I64 {
    mag: bigint;
    sign: boolean;
}

// Type definition for `game::models::battle::entity::turnBar::TurnBar` struct
export interface TurnBar {
    entityIndex: number;
    speed: bigint;
    turnbar: bigint;
    incrementStep: bigint;
    decimals: bigint;
}

// Type definition for `game::models::battle::entity::statistics::statistic::Statistic` struct
export interface Statistic {
    value: bigint;
    malus: StatModifier;
    bonus: StatModifier;
}

// Type definition for `game::models::battle::entity::AllyOrEnemy` enum
type AllyOrEnemy = { type: 'Ally'; } | { type: 'Enemy'; }

// Type definition for `game::models::storage::statistics::baseStatistics::BaseStatistics` struct
export interface BaseStatistics {
    heroName: string;
    statistics: Statistics;
}


// Type definition for `game::models::storage::arena::arenaTeam::ArenaTeam` struct
export interface ArenaTeam {
    owner: string;
    index: number;
    heroIndex: number;
}


// Type definition for `game::models::storage::battles::arenaBattleStorage::ArenaBattleStorage` struct
export interface ArenaBattleStorage {
    owner: string;
    enemyOwner: string;
}


// Type definition for `game::models::storage::arena::enemyRanges::EnemyRanges` struct
export interface EnemyRanges {
    index: number;
    minRank: bigint;
    range: bigint;
}


// Type definition for `game::models::storage::skill::skillBuff::SkillBuff` struct
export interface SkillBuff {
    skillName: string;
    index: number;
    buff: Buff;
}

// Type definition for `game::models::battle::entity::skill::buff::Buff` struct
export interface Buff {
    buffType: BuffType;
    value: bigint;
    duration: number;
    target: boolean;
    aoe: boolean;
    self: boolean;
}

// Type definition for `game::models::battle::entity::skill::buff::BuffType` enum
type BuffType = { type: 'SpeedUp'; } | { type: 'SpeedDown'; } | { type: 'AttackUp'; } | { type: 'AttackDown'; } | { type: 'DefenseUp'; } | { type: 'DefenseDown'; } | { type: 'Poison'; } | { type: 'Regen'; } | { type: 'Stun'; }

// Type definition for `game::models::storage::arena::arenaCurrentRankIndex::ArenaCurrentRankIndex` struct
export interface ArenaCurrentRankIndex {
    id: number;
    currentRankIndex: bigint;
}


// Type definition for `game::models::account::runes::Runes` struct
export interface Runes {
    owner: string;
    index: number;
    rune: Rune;
}

// Type definition for `game::models::hero::rune::runeBonus::RuneBonus` struct
export interface RuneBonus {
    statistic: RuneStatistic;
    isPercent: boolean;
}

// Type definition for `game::models::hero::rune::Rune` struct
export interface Rune {
    id: number;
    statistic: RuneStatistic;
    isPercent: boolean;
    rank: number;
    rarity: RuneRarity;
    runeType: RuneType;
    isEquipped: boolean;
    heroEquipped: number;
    rank4Bonus: RuneBonus;
    rank8Bonus: RuneBonus;
    rank12Bonus: RuneBonus;
    rank16Bonus: RuneBonus;
}

// Type definition for `game::models::hero::rune::RuneType` enum
type RuneType = { type: 'First'; } | { type: 'Second'; } | { type: 'Third'; } | { type: 'Fourth'; } | { type: 'Fifth'; } | { type: 'Sixth'; }
// Type definition for `game::models::hero::rune::RuneRarity` enum
type RuneRarity = { type: 'Common'; } | { type: 'Uncommon'; } | { type: 'Rare'; } | { type: 'Epic'; } | { type: 'Legendary'; }
// Type definition for `game::models::hero::rune::RuneStatistic` enum
type RuneStatistic = { type: 'Health'; } | { type: 'Attack'; } | { type: 'Defense'; } | { type: 'Speed'; }

// Type definition for `game::models::storage::battles::turnTimelineStorage::TurnTimelineStorage` struct
export interface TurnTimelineStorage {
    owner: string;
    map: number;
    index: number;
    entityIndex: number;
}


// Type definition for `game::models::battle::entity::skill::heal::Heal` struct
export interface Heal {
    value: bigint;
    target: boolean;
    aoe: boolean;
    self: boolean;
    healType: HealType;
}

// Type definition for `game::models::battle::entity::skill::damage::Damage` struct
export interface Damage {
    value: bigint;
    target: boolean;
    aoe: boolean;
    self: boolean;
    damageType: DamageType;
}

// Type definition for `game::models::storage::skill::skillInfos::SkillInfos` struct
export interface SkillInfos {
    name: string;
    cooldown: number;
    damage: Damage;
    heal: Heal;
    targetType: TargetType;
    accuracy: number;
    buffsCount: number;
}

// Type definition for `game::models::battle::entity::skill::TargetType` enum
type TargetType = { type: 'Ally'; } | { type: 'Enemy'; }
// Type definition for `game::models::battle::entity::skill::damage::DamageType` enum
type DamageType = { type: 'Flat'; } | { type: 'Percent'; }
// Type definition for `game::models::battle::entity::skill::heal::HealType` enum
type HealType = { type: 'Flat'; } | { type: 'Percent'; }

// Type definition for `game::models::storage::statistics::bonusRuneStatistics::BonusRuneStatistics` struct
export interface BonusRuneStatistics {
    statistic: RuneStatistic;
    rarity: RuneRarity;
    isPercent: boolean;
    value: number;
}


// Type definition for `game::models::storage::statistics::runeStatistics::RuneStatistics` struct
export interface RuneStatistics {
    statistic: RuneStatistic;
    rarity: RuneRarity;
    isPercent: boolean;
    value: number;
}


// Type definition for `game::models::storage::arena::gemsRewards::GemsRewards` struct
export interface GemsRewards {
    index: number;
    minRank: bigint;
    gems: bigint;
}


class BaseCalls {
    contractAddress: string;
    account?: Account;

    constructor(contractAddress: string, account?: Account) {
        this.account = account;
        this.contractAddress = contractAddress;
    }

    async execute(entrypoint: string, calldata: any[] = []): Promise<void> {
        if (!this.account) {
            throw new Error("No account set to interact with dojo_starter");
        }

        await this.account.execute(
            {
                contractAddress: this.contractAddress,
                entrypoint,
                calldata,
            },
            undefined,
            {
                maxFee: 0,
            }
        );
    }
}

class GameCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }
    
    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }

    async dojoResource(): Promise<void> {
        try {
            await this.execute("dojo_resource", [])
        } catch (error) {
            console.error("Error executing dojoResource:", error);
            throw error;
        }
    }

    async startPvpBattle(enemyOwner: string, heroesIds: number[]): Promise<void> {
        try {
            await this.execute("startPvpBattle", [enemyOwner,
                heroesIds])
        } catch (error) {
            console.error("Error executing startPvpBattle:", error);
            throw error;
        }
    }

    async playArenaTurn(spellIndex: number, targetIndex: number): Promise<void> {
        try {
            await this.execute("playArenaTurn", [spellIndex,
                targetIndex])
        } catch (error) {
            console.error("Error executing playArenaTurn:", error);
            throw error;
        }
    }

    async startBattle(heroesIds: number[], map: number, level: number): Promise<void> {
        try {
            await this.execute("startBattle", [heroesIds,
                map,
                level])
        } catch (error) {
            console.error("Error executing startBattle:", error);
            throw error;
        }
    }

    async playTurn(map: number, spellIndex: number, targetIndex: number): Promise<void> {
        try {
            await this.execute("playTurn", [map,
                spellIndex,
                targetIndex])
        } catch (error) {
            console.error("Error executing playTurn:", error);
            throw error;
        }
    }

    async initPvp(heroesIds: number[]): Promise<void> {
        try {
            await this.execute("initPvp", [heroesIds])
        } catch (error) {
            console.error("Error executing initPvp:", error);
            throw error;
        }
    }

    async setPvpTeam(heroesIds: number[]): Promise<void> {
        try {
            await this.execute("setPvpTeam", [heroesIds])
        } catch (error) {
            console.error("Error executing setPvpTeam:", error);
            throw error;
        }
    }

    async equipRune(runeId: number, heroId: number): Promise<void> {
        try {
            await this.execute("equipRune", [runeId,
                heroId])
        } catch (error) {
            console.error("Error executing equipRune:", error);
            throw error;
        }
    }

    async unequipRune(runeId: number): Promise<void> {
        try {
            await this.execute("unequipRune", [runeId])
        } catch (error) {
            console.error("Error executing unequipRune:", error);
            throw error;
        }
    }

    async upgradeRune(runeId: number): Promise<void> {
        try {
            await this.execute("upgradeRune", [runeId])
        } catch (error) {
            console.error("Error executing upgradeRune:", error);
            throw error;
        }
    }

    async mintHero(): Promise<void> {
        try {
            await this.execute("mintHero", [])
        } catch (error) {
            console.error("Error executing mintHero:", error);
            throw error;
        }
    }

    async mintRune(): Promise<void> {
        try {
            await this.execute("mintRune", [])
        } catch (error) {
            console.error("Error executing mintRune:", error);
            throw error;
        }
    }

    async createAccount(username: string): Promise<void> {
        try {
            await this.execute("createAccount", [username])
        } catch (error) {
            console.error("Error executing createAccount:", error);
            throw error;
        }
    }
}
class SettingsCalls extends BaseCalls {
    constructor(contractAddress: string, account?: Account) {
        super(contractAddress, account);
    }
    
    async dojoResource(): Promise<void> {
        try {
            await this.execute("dojo_resource", [])
        } catch (error) {
            console.error("Error executing dojoResource:", error);
            throw error;
        }
    }

    async initSettings(): Promise<void> {
        try {
            await this.execute("initSettings", [])
        } catch (error) {
            console.error("Error executing initSettings:", error);
            throw error;
        }
    }

    async dojoInit(): Promise<void> {
        try {
            await this.execute("dojo_init", [])
        } catch (error) {
            console.error("Error executing dojoInit:", error);
            throw error;
        }
    }
}

type Query = Partial<{
    BattleStorage: ModelClause<BattleStorage>;
    ArenaConfig: ModelClause<ArenaConfig>;
    ArenaAccount: ModelClause<ArenaAccount>;
    LevelInfos: ModelClause<LevelInfos>;
    HealthOnTurnProcStorage: ModelClause<HealthOnTurnProcStorage>;
    Heroes: ModelClause<Heroes>;
    LevelEnemy: ModelClause<LevelEnemy>;
    Account: ModelClause<Account>;
    SkillNameSet: ModelClause<SkillNameSet>;
    EntityStorage: ModelClause<EntityStorage>;
    BaseStatistics: ModelClause<BaseStatistics>;
    ArenaTeam: ModelClause<ArenaTeam>;
    ArenaBattleStorage: ModelClause<ArenaBattleStorage>;
    EnemyRanges: ModelClause<EnemyRanges>;
    SkillBuff: ModelClause<SkillBuff>;
    ArenaCurrentRankIndex: ModelClause<ArenaCurrentRankIndex>;
    Runes: ModelClause<Runes>;
    TurnTimelineStorage: ModelClause<TurnTimelineStorage>;
    SkillInfos: ModelClause<SkillInfos>;
    BonusRuneStatistics: ModelClause<BonusRuneStatistics>;
    RuneStatistics: ModelClause<RuneStatistics>;
    GemsRewards: ModelClause<GemsRewards>;
}>;

type ResultMapping = {
    BattleStorage: BattleStorage;
    ArenaConfig: ArenaConfig;
    ArenaAccount: ArenaAccount;
    LevelInfos: LevelInfos;
    HealthOnTurnProcStorage: HealthOnTurnProcStorage;
    Heroes: Heroes;
    LevelEnemy: LevelEnemy;
    Account: Account;
    SkillNameSet: SkillNameSet;
    EntityStorage: EntityStorage;
    BaseStatistics: BaseStatistics;
    ArenaTeam: ArenaTeam;
    ArenaBattleStorage: ArenaBattleStorage;
    EnemyRanges: EnemyRanges;
    SkillBuff: SkillBuff;
    ArenaCurrentRankIndex: ArenaCurrentRankIndex;
    Runes: Runes;
    TurnTimelineStorage: TurnTimelineStorage;
    SkillInfos: SkillInfos;
    BonusRuneStatistics: BonusRuneStatistics;
    RuneStatistics: RuneStatistics;
    GemsRewards: GemsRewards;
};

type QueryResult<T extends Query> = {
    [K in keyof T]: K extends keyof ResultMapping ? ResultMapping[K] : never;
};

// Only supports a single model for now, since torii doesn't support multiple models
// And inside that single model, there's only support for a single query.
function convertQueryToToriiClause(query: Query): Clause | undefined {
    const [model, clause] = Object.entries(query)[0];

    if (Object.keys(clause).length === 0) {
        return undefined;
    }

    const clauses: Clause[] = Object.entries(clause).map(([key, value]) => {
        return {
            Member: {
                model,
                member: key,
                ...valueToToriiValueAndOperator(value),
            },
        } satisfies Clause;
    });

    return clauses[0];
}
type GeneralParams = {
    toriiUrl?: string;
    relayUrl?: string;
    account?: Account;
};

type InitialParams = GeneralParams &
    (
        | {
                rpcUrl?: string;
                worldAddress: string;
                gameAddress: string;
    settingsAddress: string;
            }
        | {
                manifest: any;
            }
    );

export class Game {
    rpcUrl: string;
    toriiUrl: string;
    toriiPromise: Promise<Client>;
    relayUrl: string;
    worldAddress: string;
    private _account?: Account;
    game: GameCalls;
    gameAddress: string;
    settings: SettingsCalls;
    settingsAddress: string;

    constructor(params: InitialParams) {
        if ("manifest" in params) {
            const config = createManifestFromJson(params.manifest);
            this.rpcUrl = config.world.metadata.rpc_url;
            this.worldAddress = config.world.address;

            const gameAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::game::game"
            )?.address;

            if (!gameAddress) {
                throw new Error("No game contract found in the manifest");
            }

            this.gameAddress = gameAddress;
    const settingsAddress = config.contracts.find(
                (contract) =>
                    contract.name === "dojo_starter::systems::settings::settings"
            )?.address;

            if (!settingsAddress) {
                throw new Error("No settings contract found in the manifest");
            }

            this.settingsAddress = settingsAddress;
        } else {
            this.rpcUrl = params.rpcUrl || LOCAL_KATANA;
            this.worldAddress = params.worldAddress;
            this.gameAddress = params.gameAddress;
    this.settingsAddress = params.settingsAddress;
        }
        this.toriiUrl = params.toriiUrl || LOCAL_TORII;
        this.relayUrl = params.relayUrl || LOCAL_RELAY;
        this._account = params.account;
        this.game = new GameCalls(this.gameAddress, this._account);
    this.settings = new SettingsCalls(this.settingsAddress, this._account);

        this.toriiPromise = createClient([], {
            rpcUrl: this.rpcUrl,
            toriiUrl: this.toriiUrl,
            worldAddress: this.worldAddress,
            relayUrl: this.relayUrl,
        });
    }

    get account(): Account | undefined {
        return this._account;
    }

    set account(account: Account) {
        this._account = account;
        this.game = new GameCalls(this.gameAddress, this._account);
    this.settings = new SettingsCalls(this.settingsAddress, this._account);
    }

    async query<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        return {
            torii,
            findEntities: async () => this.findEntities(query, limit, offset),
        };
    }

    async findEntities<T extends Query>(query: T, limit = 10, offset = 0) {
        const torii = await this.toriiPromise;

        const clause = convertQueryToToriiClause(query);

        const toriiResult = await torii.getEntities({
            limit,
            offset,
            clause,
        });

        return toriiResult as Record<string, QueryResult<T>>;
    }

    async findEntity<T extends Query>(query: T) {
        const result = await this.findEntities(query, 1);

        if (Object.values(result).length === 0) {
            return undefined;
        }

        return Object.values(result)[0] as QueryResult<T>;
    }
}